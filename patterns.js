const canvas = document.getElementById("canvas")
const input = form.value
const output = convertDataToHTML(result)



display.append(element)

return response
return newPosition
return topElement

const getData = () => {
}
const updateData = (index, newValue) =>{
}
const addNewData = (newObj) => {
}

///////////////////////////////////////////////////////////////////////

const Node = {
	id: 1,
	value: "stateName",
	connectedFrom: 4,
	connectedTo: [20, 3]
}
const Proposition = {
	id: 302,
	statement: 'Some of the possible state about the world is true according to observations made in real life',
	isTrue: true,
	categories: ["oboject", "state", "relation", causality"]
}
const player = {
	x: 300,
	y: 200,
	speed: 2,
	direction: Math.PI
}
const vector = {
	x: 30,
	y: 2,
	z: -14,
}
const relation = {
	from: obj[123],
	to: obj[3],
	connectionWeight: "high",
	timeAt: 2030:Jan:1st,
	placeAt: {x: "134.23.21", y:"135.23.53"},
	state: "active",
}
const address = {
	home: "Prefecture, City, Street, Number",
	destination: "address",

}


user.name
user.isValid
user.isAdmin
user.email
user.joinedAt
user.IP
user.level
user.state
user.intimacy(otherUser)

cursor.x
cursor.y
window.width
window.height


////////////////////////////////////////////////////////////////////////////////

arrays = [
	"element", value, object
]
users = [
	{id: 1, name: "NameName", coordinate: "address"},
	{id: 2, name: "Name2", coordinate: "address2"}
]

users.forEach(user => {
	if(user.state === "active"){
		activeUser.push(user)
	}
})

if(obj.createdAt >= oneWeekAgo()){
}

const dom = {
	tag: "div",
	class: ["show", "display"],
	content: doms.forEach.dom.id === 3
}

const objects = {
	object1: {id: 1, value: 222, state: "active", position: {x: 234, y: 123}},
	object2:
}


/////////////////////////////////////////////////////////////////////////////////



originaiArray = []
listOfObjs = []
partialArray = []


//////////////////////////////////////////////////////////////////////////

question2.correctUsers = []
user32.question2.correct = true



grid[20][5] = [obj1, obj3, obj5]
grid[row][column].push(newObj)

windowHeight
rowCellHeight
rowIndex

const rowIndex = e.clientY / rowCellHeight

objectUniqueIndex = 123
x[objectUniqueIndex] =
speed[objectUniqueIndex] =

//-----------------------------------------------------------

doms = []
doms.forEach(dom => {generateDom(dom)})

structure = {
	large: [size:, area:, layers:],
	medium: [size:, area:, layers:],
	small: ,
}

function(chosenSize){

}

window.onclick

newDom = <tag class="className">content</tag>
display.innerHTML = newDom


const inputString = form.string.value

form.addEventListener(

class DOM {
	addEventListener(event, functionBlock){

	}
}

----------------------------

variables

const instance = new Class()
const obj = {}
const array = []

let index = 0;
let count = 0;
let total;

let lastIndex;
let lastUpdatedValue;
let objKeyString;

const seed;

const userInput;
const uploadedFile;
const blob;
const img;
const audioData;



pointer

const display = document.getElementById("idName");
const domElements = document.querySelectorAll(.elements)



//------------updating value-----------------

let input = document.getElementById("input-form").value

let truthValue ==


//////////////////////////// object //////////////////////////
obj(class)

const inputMap = {
	up: true,
	down: false,
	key1: true,

}
const savedConfig = {
	size:,
	speed:,
	level:,
	score:,
}


////////////////////////// class //////////////////////////
class

class App{
	constructor(){
		const obj = new Object(option1, setting, request)
		const dataNetworkr = new DataNetworok(size);
		const displayController = new DisplayController();
	}
}

class Canvas {
}
class Context{
}
class Object{
  constructor(){
    this.init();
  }
  beforeMethod(){
    // code here
  }
  someMethod(){
    this.beforeMethod();
    // code here
  }

}

const app = new App();
const currentUser = new User();




instance.property = newValue;
insntance.setFormattedValueToProperty = unformattedValue;
instance.show()




///////////////////////////// array //////////////////////////
array

const seriesOfData = [1,0,0,0,10,50,3,2,1,0,0,0,1]

instances.push()
aliveInsntances.push()
preservedPointers.push()


stackFunctions.forEach(function => {
  function()
})




///////////////////////////// function //////////////////////////
function

(index, value)
(array)
(obj)
(variable)
(function)
(functions)

{
  // code here

}


return this
return resutl
return obj
return array
return variable
return function
return functions



//////////////////////////  condition //////////////////////////
if(variable === 'value')
if(binary === true)
if(flag === true)
if(key === 'enter)
if(array.length < 0)



switch(eventPatterns){
	case 'change':
		;
	case 'input';
}

switch(key){
	case 'space':
		;
	case 'enter':
		;
}

////////////////////////// loop //////////////////////////
while

while(stack.length > 0){
}
while(flag === true){
}
while(flag !== true){

}

for(let i = 0; i < array.length; i++){
  array[i]
  array[i+1]
  elements[i-1]

  objects[i].property
  objects[i].method()


}

array.forEach((element) => {
})

for(let key in obj){
}

for(let obj of array){
}


////////////////////////// timing //////////////////////////

setTimeout(() => {
})
setInterval(() => {
})
requestAnimationFrame(() => {
})
clearTimeout(() => {
})
clearInterval(() => {
})
cancelAnimationFrame(() => {
})

let startTime;
const timeoutID = setTimeout(() => {
  startTime = new Date().getTime()
  callFunction()
}, 1000)
button.addEventListener('click', () => {
  if(new Date().getTime() - startTime > 1000){
    clearTimeout(timeoutID)
  }
});

const intervalID = setInterval(() => {
  repeatedEvent();
}, 1000)
document.addEventListener("scroll", () => {
  clearInterval(intervalID)
})


function callFunctionAtRandomTime(){
  let minDelay = 1000;
  let maxDelay = 5000;
  let randomDelay = Math.floor(Math.random() * (maxDelay - minDelay + 1)) + minDelay;

  myFuncion();
  setTimeout(callFunctionAtRandomTime, randomDelay)
}

let startTime;
let interval = 1000;
let previousTimestamp;
let randomInterval = Math.floor(Math.random() * (2000 - 500 + 1)) + 500;
function loop(timestamp){
  if(!startTime) startTime = timestamp;

  if(timestamp - startTime > interval){
    startTime = timestamp;
    // code here
  }
  if(timestamp - previousTimestamp > randomInterval){
    previousTimestamp = timestamp;
    // code here

    randomInterval = Math.floor(Math.random() * (2000 - 500 + 1)) + 500;
  }
  requestAnimationFrame(loop);
}



////////////////////////// event //////////////////////////

window.addEventListener('scroll', () => {
  if (document.documentElement.scrollTop > 100) {
    console.log('more than 100px')
  } else {
    console.log('less than 100px')
  }
})

///throttle
let ticking = false;
if (!ticking) {
  requestAnimationFrame(() => {
    ticking = false;
    update();
  })

  ticking = true;
}

////////////////////////// canvas //////////////////////////

const canvas = document.getElementById('canvas')
const ctx = canvas.getContext('2d')
canvas.width = window.innerWidth
canvas.height = window.innerHeight

ctx.save() // save the current state
// code here will not affect the next drawing
// space for temporary transformation
ctx.restore() // restore the last saved state


/////////////////////// data structure ///////////////////////

const obj = {
  property: value,
  method(){
    // code here
  }
}

const array = [1,2,3,4,5]

const stack = []
stack.push()
stack.pop()

const queue = []
queue.push()
queue.shift()

const linkedList = {
  head: {
    value: 1,
    next: {
      value: 2,
      next: {
        value: 3,
        next: null
      }
    }
  }
}

const tree = {
  value: 1,
  left: {
    value: 2,
    left: null,
    right: null
  },
  right: {
    value: 3,
    left: null,
    right: {
      value: 4,
      left: null,
      right: null

    }
  }
}

tree.left.left = {
  value: 5,
  left: null,
  right: null
}

tree.right.left = {
  value: 6,
  left: null,
  right: null
}

const graph = {
  1: [2,3,4],
  2: [1,3,5],
  3: [1,2,4],
  4: [1,3,5],
  5: [2,4]
}

graph[1].push(5)
graph[5].push(1)
randomIndex = Math.floor(Math.random() * array.length)
const connectedTo = graph[randomIndex]
randomIndex = Math.floor(Math.random() * connectedTo.length)
const randomNode = connectedTo[randomIndex]

function traverseGraphRandomlyUntilReachingNode(node){
  let currentNode = 1
  const visited = new Set()
  const sequence = []
  while(currentNode !== node){
    const connectedTo = graph[currentNode]
    const randomIndex = Math.floor(Math.random() * connectedTo.length)
    currentNode = connectedTo[randomIndex]
    visited.add(currentNode)
    sequence.push(currentNode)
  }
}


const weightedGraph = {
  1: [{node: 2, weight: 10}, {node: 3, weight: 20}, {node: 4, weight: 30}],
  2: [{node: 1, weight: 10}, {node: 3, weight: 20}, {node: 5, weight: 30}],
  3: [{node: 1, weight: 20}, {node: 2, weight: 20}, {node: 4, weight: 10}],
  4: [{node: 1, weight: 30}, {node: 3, weight: 10}, {node: 5, weight: 20}],
  5: [{node: 2, weight: 30}, {node: 4, weight: 20}]
}

const matrix = [
  [0, 10, 20, 30, 0],
  [10, 0, 20, 0, 30],
  [20, 20, 0, 10, 0],
  [30, 0, 10, 0, 20],
  [0, 30, 0, 20, 0]
]

const adjacencyMatrix = [
  [0, 1, 1, 1, 0],
  [1, 0, 1, 0, 1],
  [1, 1, 0, 1, 0],
  [1, 0, 1, 0, 1],
  [0, 1, 0, 1, 0]
]

const adjacencyList = {
  1: [2,3,4],
  2: [1,3,5],
  3: [1,2,4],
  4: [1,3,5],
  5: [2,4]
}


class Node {
  constructor(value){
    this.value = value
    this.left = null
    this.right = null
  }
}

class Tree {
  constructor(){
    this.root = null
  }
  insert(value){
    const newNode = new Node(value)
    if(!this.root){
      this.root = newNode
    } else {
      let currentNode = this.root
      while(true){
        if(value < currentNode.value){
          if(!currentNode.left){
            currentNode.left = newNode
            return this
          }
          currentNode = currentNode.left
        } else {
          if(!currentNode.right){
            currentNode.right = newNode
            return this
          }
          currentNode = currentNode.right
        }
      }
    }
  }
  search(value){
    let currentNode = this.root
    while(currentNode){
      if(value === currentNode.value){
        return currentNode
      } else if(value < currentNode.value){
        currentNode = currentNode.left
      } else {
        currentNode = currentNode.right
      }
    }
    return null
  }
}


/////////////////////// algorithm ///////////////////////

const sort = (array) => {
  return array.sort((a, b) => a - b)
}

const binarySearch = (array, target) => {
  let left = 0
  let right = array.length - 1

  while(left <= right){
    let mid = Math.floor((left + right) / 2)
    if(array[mid] === target){
      return mid
    } else if(array[mid] < target){
      left = mid + 1
    } else {
      right = mid - 1
    }
  }
  return -1
}

const bubbleSort = (array) => {
  for(let i = 0; i < array.length; i++){
    for(let j = 0; j < array.length - i - 1; j++){
      if(array[j] > array[j+1]){
        let temp = array[j]
        array[j] = array[j+1]
        array[j+1] = temp
      }
    }
  }
  return array
}


function twoLinesCrossed(line1, line2){
  const [x1, y1, x2, y2] = line1
  const [x3, y3, x4, y4] = line2
  const a1 = (y2 - y1) / (x2 - x1) // slope of line1
  const a2 = (y4 - y3) / (x4 - x3) // slope of line2
  const b1 = y1 - a1 * x1 // y-intercept of line1
  const b2 = y3 - a2 * x3 // y-intercept of line2
  if(a1 === a2){ // parallel
    return false
  }
  const x = (b2 - b1) / (a1 - a2) // x-coordinate of intersection
  const y = a1 * x + b1 // y-coordinate of intersection
  return x >= Math.min(x1, x2) && x <= Math.max(x1, x2) && x >= Math.min(x3, x4) && x <= Math.max(x3, x4)

}
